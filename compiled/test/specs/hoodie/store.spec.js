// Generated by CoffeeScript 1.3.3

define('specs/hoodie/store', ['hoodie/store', 'mocks/hoodie'], function(Store, HoodieMock) {
  return describe("Store", function() {
    beforeEach(function() {
      this.hoodie = new HoodieMock;
      this.store = new Store(this.hoodie);
      spyOn(this.store, "_setObject").andCallThrough();
      spyOn(this.store, "_getObject").andCallThrough();
      spyOn(this.store.db, "getItem").andCallThrough();
      spyOn(this.store.db, "setItem").andCallThrough();
      spyOn(this.store.db, "removeItem").andCallThrough();
      return spyOn(this.store.db, "clear").andCallThrough();
    });
    describe("new", function() {
      return it("should subscribe to account:signed_out event", function() {
        var store;
        spyOn(this.hoodie, "on");
        store = new Store(this.hoodie);
        return expect(this.hoodie.on).wasCalledWith('account:signed_out', store.clear);
      });
    });
    describe(".save(type, id, object, options)", function() {
      beforeEach(function() {
        spyOn(this.store, "_now").andReturn('now');
        return spyOn(this.store, "cache").andReturn('cached_object');
      });
      it("should return a promise", function() {
        var promise;
        promise = this.store.save('document', '123', {
          name: 'test'
        });
        return expect(promise).toBePromise();
      });
      describe("invalid arguments", function() {
        _when("no arguments passed", function() {
          return it("should be rejected", function() {
            return expect(this.store.save()).toBeRejected();
          });
        });
        return _when("no object passed", function() {
          return it("should be rejected", function() {
            var promise;
            promise = this.store.save('document', 'abc4567');
            return expect(promise).toBeRejected();
          });
        });
      });
      _when("id is '123', type is 'document', object is {name: 'test'}", function() {
        beforeEach(function() {
          return this.promise = this.store.save('document', '123', {
            name: 'test'
          }, {
            option: 'value'
          });
        });
        it("should cache document", function() {
          return expect(this.store.cache).wasCalled();
        });
        it("should add timestamps", function() {
          var object;
          object = this.store.cache.mostRecentCall.args[2];
          expect(object.created_at).toBe('now');
          return expect(object.updated_at).toBe('now');
        });
        _and("options.remote is true", function() {
          it("should not touch created_at / updated_at timestamps", function() {
            var object;
            this.store.save('document', '123', {
              name: 'test'
            }, {
              remote: true
            });
            object = this.store.cache.mostRecentCall.args[2];
            expect(object.created_at).toBeUndefined();
            return expect(object.updated_at).toBeUndefined();
          });
          return it("should add a _synced_at timestamp", function() {
            var object;
            this.store.save('document', '123', {
              name: 'test'
            }, {
              remote: true
            });
            object = this.store.cache.mostRecentCall.args[2];
            return expect(object._synced_at).toBe('now');
          });
        });
        _and("options.silent is true", function() {
          return it("should not touch created_at / updated_at timestamps", function() {
            var object;
            this.store.save('document', '123', {
              name: 'test'
            }, {
              silent: true
            });
            object = this.store.cache.mostRecentCall.args[2];
            expect(object.created_at).toBeUndefined();
            return expect(object.updated_at).toBeUndefined();
          });
        });
        it("should pass options", function() {
          var options;
          options = this.store.cache.mostRecentCall.args[3];
          return expect(options.option).toBe('value');
        });
        _when("successful", function() {
          beforeEach(function() {
            return this.store.cache.andReturn('doc');
          });
          it("should resolve the promise", function() {
            return expect(this.promise).toBeResolved();
          });
          it("should pass the object to done callback", function() {
            return expect(this.promise).toBeResolvedWith('cached_object', true);
          });
          _and("object did exist before", function() {
            beforeEach(function() {
              this.store._cached['document/123'] = {};
              return this.promise = this.store.save('document', '123', {
                name: 'test'
              }, {
                option: 'value'
              });
            });
            return it("should pass false (= not created) as the second param to the done callback", function() {
              return expect(this.promise).toBeResolvedWith('doc', false);
            });
          });
          return _and("object did not exist before", function() {
            beforeEach(function() {
              delete this.store._cached['document/123'];
              return this.promise = this.store.save('document', '123', {
                name: 'test'
              }, {
                option: 'value'
              });
            });
            return it("should pass true (= new created) as the second param to the done callback", function() {
              return expect(this.promise).toBeResolvedWith('doc', true);
            });
          });
        });
        return _when("failed", function() {
          beforeEach(function() {
            return this.store.cache.andCallFake(function() {
              throw new Error("i/o error");
            });
          });
          return it("should return a rejected promise", function() {
            var promise;
            promise = this.store.save('document', '123', {
              name: 'test'
            });
            return expect(promise).toBeRejected();
          });
        });
      });
      _when("id is '123', type is 'document', object is {id: '123', type: 'document', name: 'test'}", function() {
        beforeEach(function() {
          var key, type, _ref;
          this.store.save('document', '123', {
            id: '123',
            type: 'document',
            name: 'test'
          });
          return _ref = this.store.cache.mostRecentCall.args, type = _ref[0], key = _ref[1], this.object = _ref[2], _ref;
        });
        it("should cache the object without the id attribute", function() {
          return expect(this.object.id).toBeUndefined();
        });
        return it("should store the object without the type attribute", function() {
          return expect(this.object.type).toBeUndefined();
        });
      });
      _when("id is '123', type is '$internal', object is {action: 'do some background magic'}}", function() {
        beforeEach(function() {
          return this.promise = this.store.save('$internal', '123', {
            action: 'do some background magic'
          });
        });
        return it("should work", function() {
          return expect(this.promise).toBeResolved();
        });
      });
      it("should not overwrite created_at attribute", function() {
        var id, object, type, _ref;
        this.store.save('document', '123', {
          created_at: 'check12'
        });
        _ref = this.store.cache.mostRecentCall.args, type = _ref[0], id = _ref[1], object = _ref[2];
        return expect(object.created_at).toBe('check12');
      });
      it("should allow numbers and lowercase letters for for type only. And must start with a letter or $", function() {
        var invalid, key, promise, valid, _i, _j, _len, _len1, _results;
        invalid = ['UPPERCASE', 'under_lines', '-?&$', '12345', 'a'];
        valid = ['car', '$email'];
        for (_i = 0, _len = invalid.length; _i < _len; _i++) {
          key = invalid[_i];
          promise = this.store.save(key, 'valid', {});
          expect(promise).toBeRejected();
        }
        _results = [];
        for (_j = 0, _len1 = valid.length; _j < _len1; _j++) {
          key = valid[_j];
          promise = this.store.save(key, 'valid', {});
          _results.push(expect(promise).toBeResolved());
        }
        return _results;
      });
      it("should allow numbers and lowercase letters for for id only", function() {
        var invalid, key, promise, valid, _i, _j, _len, _len1, _results;
        invalid = ['UPPERCASE', 'under_lines', '-?&$'];
        valid = ['abc4567', '1', 123];
        for (_i = 0, _len = invalid.length; _i < _len; _i++) {
          key = invalid[_i];
          promise = this.store.save('valid', key, {});
          expect(promise).toBeRejected();
        }
        _results = [];
        for (_j = 0, _len1 = valid.length; _j < _len1; _j++) {
          key = valid[_j];
          promise = this.store.save('valid', key, {});
          _results.push(expect(promise).toBeResolved());
        }
        return _results;
      });
      return _when("called without id", function() {
        beforeEach(function() {
          var _ref;
          this.promise = this.store.save('document', void 0, {
            name: 'test'
          }, {
            option: 'value'
          });
          return _ref = this.store.cache.mostRecentCall.args, this.type = _ref[0], this.key = _ref[1], this.object = _ref[2], _ref;
        });
        it("should generate an id", function() {
          return expect(this.key).toMatch(/^[a-z0-9]{7}$/);
        });
        it("should pass options", function() {
          var options;
          options = this.store.cache.mostRecentCall.args[3];
          return expect(options.option).toBe('value');
        });
        return _when("successful", function() {
          it("should resolve the promise", function() {
            return expect(this.promise).toBeResolved();
          });
          it("should pass the object to done callback", function() {
            return expect(this.promise).toBeResolvedWith('cached_object', true);
          });
          return it("should pass true (= created) as the second param to the done callback", function() {
            return expect(this.promise).toBeResolvedWith('cached_object', true);
          });
        });
      });
    });
    describe(".create(type, object, options)", function() {
      beforeEach(function() {
        return spyOn(this.store, "save").andReturn('promise');
      });
      return it("should call .save(type, undefined, options) and return its promise", function() {
        var promise;
        promise = this.store.create('couch', {
          funky: 'fresh'
        });
        expect(this.store.save).wasCalledWith('couch', void 0, {
          funky: 'fresh'
        });
        return expect(promise).toBe('promise');
      });
    });
    describe(".update(type, id, update, options)", function() {
      beforeEach(function() {
        spyOn(this.store, "load");
        return spyOn(this.store, "save").andReturn({
          then: function() {}
        });
      });
      _when("object cannot be found", function() {
        beforeEach(function() {
          this.store.load.andReturn($.Deferred().reject());
          return this.promise = this.store.update('couch', '123', {
            funky: 'fresh'
          });
        });
        return it("should create it", function() {
          return expect(this.store.save).wasCalledWith('couch', '123', {
            funky: 'fresh'
          }, {});
        });
      });
      return _when("object can be found", function() {
        beforeEach(function() {
          this.store.load.andReturn($.Deferred().resolve({
            style: 'baws'
          }));
          return this.store.save.andReturn($.Deferred().resolve('resolved by save'));
        });
        _and("update is an object", function() {
          beforeEach(function() {
            return this.promise = this.store.update('couch', '123', {
              funky: 'fresh'
            });
          });
          it("should save the updated object", function() {
            return expect(this.store.save).wasCalledWith('couch', '123', {
              style: 'baws',
              funky: 'fresh'
            }, {});
          });
          return it("should return a resolved promise", function() {
            return expect(this.promise).toBeResolvedWith('resolved by save');
          });
        });
        _and("update is a function", function() {
          beforeEach(function() {
            return this.promise = this.store.update('couch', '123', function(obj) {
              return {
                funky: 'fresh'
              };
            });
          });
          it("should save the updated object", function() {
            return expect(this.store.save).wasCalledWith('couch', '123', {
              style: 'baws',
              funky: 'fresh'
            }, {});
          });
          return it("should return a resolved promise", function() {
            return expect(this.promise).toBeResolvedWith('resolved by save');
          });
        });
        return _and("update wouldn't make a change", function() {
          beforeEach(function() {
            return this.promise = this.store.update('couch', '123', function(obj) {
              return {
                style: 'baws'
              };
            });
          });
          it("should save the object", function() {
            return expect(this.store.save).wasNotCalled();
          });
          return it("should return a resolved promise", function() {
            return expect(this.promise).toBeResolvedWith({
              style: 'baws'
            });
          });
        });
      });
    });
    describe(".updateAll(objects)", function() {
      beforeEach(function() {
        spyOn(this.hoodie, "isPromise").andReturn(false);
        return this.todo_objects = [
          {
            type: 'todo',
            id: '1'
          }, {
            type: 'todo',
            id: '2'
          }, {
            type: 'todo',
            id: '3'
          }
        ];
      });
      it("should return a promise", function() {
        return expect(this.store.updateAll(this.todo_objects, {})).toBePromise();
      });
      it("should update objects", function() {
        var obj, _i, _len, _ref, _results;
        spyOn(this.store, "update");
        this.store.updateAll(this.todo_objects, {
          funky: 'update'
        });
        _ref = this.todo_objects;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          obj = _ref[_i];
          _results.push(expect(this.store.update).wasCalledWith(obj.type, obj.id, {
            funky: 'update'
          }, {}));
        }
        return _results;
      });
      it("should resolve the returned promise once all objects have been updated", function() {
        var promise;
        promise = this.hoodie.defer().resolve().promise();
        spyOn(this.store, "update").andReturn(promise);
        return expect(this.store.updateAll(this.todo_objects, {})).toBeResolved();
      });
      it("should not resolve the retunred promise unless object updates have been finished", function() {
        var promise;
        promise = this.hoodie.defer().promise();
        spyOn(this.store, "update").andReturn(promise);
        return expect(this.store.updateAll(this.todo_objects, {})).notToBeResolved();
      });
      return _when("passed objects is a promise", function() {
        beforeEach(function() {
          return this.hoodie.isPromise.andReturn(true);
        });
        return it("should update objects returned by promise", function() {
          var obj, promise, _i, _len, _ref, _results,
            _this = this;
          promise = {
            pipe: function(cb) {
              return cb(_this.todo_objects);
            }
          };
          spyOn(this.store, "update");
          this.store.updateAll(promise, {
            funky: 'update'
          });
          _ref = this.todo_objects;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            obj = _ref[_i];
            _results.push(expect(this.store.update).wasCalledWith(obj.type, obj.id, {
              funky: 'update'
            }, {}));
          }
          return _results;
        });
      });
    });
    describe(".load(type, id)", function() {
      beforeEach(function() {
        return spyOn(this.store, "cache").andCallThrough();
      });
      it("should return a promise", function() {
        return this.promise = this.store.load('document', '123');
      });
      describe("invalid arguments", function() {
        _when("no arguments passed", function() {
          return it("should call the fail callback", function() {
            var promise;
            promise = this.store.load();
            return expect(promise).toBeRejected();
          });
        });
        return _when("no id passed", function() {
          return it("should call the fail callback", function() {
            var promise;
            promise = this.store.load('document');
            return expect(promise).toBeRejected();
          });
        });
      });
      _when("object can be found", function() {
        beforeEach(function() {
          this.store.cache.andReturn({
            name: 'test'
          });
          return this.promise = this.store.load('document', 'abc4567');
        });
        return it("should call the done callback", function() {
          return expect(this.promise).toBeResolved();
        });
      });
      _when("object cannot be found", function() {
        beforeEach(function() {
          this.store.cache.andReturn(false);
          return this.promise = this.store.load('document', 'abc4567');
        });
        return it("should call the fail callback", function() {
          return expect(this.promise).toBeRejected();
        });
      });
      return it("should cache the object after the first get", function() {
        this.store.load('document', 'abc4567');
        this.store.load('document', 'abc4567');
        return expect(this.store.db.getItem.callCount).toBe(1);
      });
    });
    describe(".loadAll(filter)", function() {
      var with_2_cats_and_3_dogs;
      with_2_cats_and_3_dogs = function(specs) {
        return _and("two cat and three dog objects exist in the store", function() {
          beforeEach(function() {
            spyOn(this.store, "_index").andReturn(["cat/1", "cat/2", "dog/1", "dog/2", "dog/3"]);
            return spyOn(this.store, "cache").andCallFake(function(type, id) {
              return {
                name: "" + type + id,
                age: parseInt(id)
              };
            });
          });
          return specs();
        });
      };
      it("should return a promise", function() {
        var promise;
        promise = this.store.loadAll();
        return expect(promise).toBePromise();
      });
      _when("called without a type", function() {
        with_2_cats_and_3_dogs(function() {
          return it("should return'em all", function() {
            var promise, results, success;
            success = jasmine.createSpy('success');
            promise = this.store.loadAll();
            promise.done(success);
            results = success.mostRecentCall.args[0];
            return expect(results.length).toBe(5);
          });
        });
        _and("no documents exist in the store", function() {
          beforeEach(function() {
            return spyOn(this.store, "_index").andReturn([]);
          });
          return it("should return an empty array", function() {
            var promise;
            promise = this.store.loadAll();
            return expect(promise).toBeResolvedWith([]);
          });
        });
        return _and("there are other documents in localStorage not stored with store", function() {
          beforeEach(function() {
            spyOn(this.store, "_index").andReturn(["_some_config", "some_other_shizzle", "whatever", "valid/123"]);
            return spyOn(this.store, "cache").andReturn({});
          });
          return it("should not return them", function() {
            var promise, results, success;
            success = jasmine.createSpy('success');
            promise = this.store.loadAll();
            promise.done(success);
            results = success.mostRecentCall.args[0];
            return expect(results.length).toBe(1);
          });
        });
      });
      return _when("called only with filter `function(obj) { return obj.age === 1}` ", function() {
        return with_2_cats_and_3_dogs(function() {
          return it("should return one dog", function() {
            var promise, results, success;
            success = jasmine.createSpy('success');
            promise = this.store.loadAll(function(obj) {
              return obj.age === 1;
            });
            promise.done(success);
            results = success.mostRecentCall.args[0];
            return expect(results.length).toBe(2);
          });
        });
      });
    });
    describe(".delete(type, id)", function() {
      _when("objecet cannot be found", function() {
        beforeEach(function() {
          return spyOn(this.store, "cache").andReturn(false);
        });
        return it("should return a rejected the promise", function() {
          var promise;
          promise = this.store["delete"]('document', '123');
          return expect(promise).toBeRejected();
        });
      });
      _when("object can be found and has not been synched before", function() {
        beforeEach(function() {
          return spyOn(this.store, "cache").andReturn({});
        });
        it("should remove the object", function() {
          this.store["delete"]('document', '123');
          return expect(this.store.db.removeItem).wasCalledWith('document/123');
        });
        it("should set the _cached object to false", function() {
          delete this.store._cached['document/123'];
          this.store["delete"]('document', '123');
          return expect(this.store._cached['document/123']).toBe(false);
        });
        it("should clear document from changed", function() {
          spyOn(this.store, "clear_changed");
          this.store["delete"]('document', '123');
          return expect(this.store.clear_changed).wasCalledWith('document', '123');
        });
        it("should return a resolved promise", function() {
          var promise;
          promise = this.store["delete"]('document', '123');
          return expect(promise).toBeResolved();
        });
        return it("should return a clone of the cached object (before it was deleted)", function() {
          var promise;
          spyOn($, "extend");
          promise = this.store["delete"]('document', '123', {
            remote: true
          });
          return expect($.extend).wasCalled();
        });
      });
      _when("object can be found and delete comes from remote", function() {
        beforeEach(function() {
          return spyOn(this.store, "cache").andReturn({
            _synced_at: 'now'
          });
        });
        return it("should remove the object", function() {
          this.store["delete"]('document', '123', {
            remote: true
          });
          return expect(this.store.db.removeItem).wasCalledWith('document/123');
        });
      });
      _when("object can be found and was synched before", function() {
        beforeEach(function() {
          return spyOn(this.store, "cache").andReturn({
            _synced_at: 'now'
          });
        });
        it("should mark the object as deleted and cache it", function() {
          var promise;
          promise = this.store["delete"]('document', '123');
          return expect(this.store.cache).wasCalledWith('document', '123', {
            _synced_at: 'now',
            _deleted: true
          });
        });
        return it("should not remove the object from store", function() {
          this.store["delete"]('document', '123');
          return expect(this.store.db.removeItem).wasNotCalled();
        });
      });
      return describe("aliases", function() {
        return it("should allow to use .destroy", function() {
          return expect(this.store.destroy).toBe(this.store["delete"]);
        });
      });
    });
    describe(".cache(type, id, object)", function() {
      beforeEach(function() {
        spyOn(this.store, "mark_as_changed");
        spyOn(this.store, "clear_changed");
        spyOn(this.store, "_is_dirty");
        spyOn(this.store, "_is_marked_as_deleted");
        return this.store._cached = {};
      });
      _when("object passed", function() {
        it("should write the object to localStorage, but without type & id attributes", function() {
          this.store.cache('couch', '123', {
            color: 'red'
          });
          return expect(this.store.db.setItem).wasCalledWith('couch/123', '{"color":"red"}');
        });
        return _when("`options.remote = true` passed", function() {
          return it("should clear changed object", function() {
            this.store.cache('couch', '123', {
              color: 'red'
            }, {
              remote: true
            });
            return expect(this.store.clear_changed).wasCalledWith('couch', '123');
          });
        });
      });
      _when("no object passed", function() {
        _and("object is already cached", function() {
          beforeEach(function() {
            return this.store._cached['couch/123'] = {
              color: 'red'
            };
          });
          return it("should not load it from localStorage", function() {
            this.store.cache('couch', '123');
            return expect(this.store.db.getItem).wasNotCalled();
          });
        });
        return _and("object is not yet cached", function() {
          beforeEach(function() {
            return delete this.store._cached['couch/123'];
          });
          _and("object does exist in localStorage", function() {
            beforeEach(function() {
              return this.store._getObject.andReturn({
                color: 'red'
              });
            });
            return it("should cache it for future", function() {
              this.store._getObject.andReturn({
                color: 'red'
              });
              this.store.cache('couch', '123');
              return expect(this.store._cached['couch/123'].color).toBe('red');
            });
          });
          return _and("object does not exist in localStorage", function() {
            beforeEach(function() {
              return this.store._getObject.andReturn(false);
            });
            it("should cache it for future", function() {
              this.store.cache('couch', '123');
              return expect(this.store._cached['couch/123']).toBe(false);
            });
            return it("should return false", function() {
              return expect(this.store.cache('couch', '123')).toBe(false);
            });
          });
        });
      });
      _when("object is dirty", function() {
        beforeEach(function() {
          return this.store._is_dirty.andReturn(true);
        });
        return it("should mark it as changed", function() {
          this.store.cache('couch', '123');
          return expect(this.store.mark_as_changed).wasCalledWith('couch', '123', {
            color: 'red',
            type: 'couch',
            id: '123'
          });
        });
      });
      _when("object is not dirty", function() {
        beforeEach(function() {
          return this.store._is_dirty.andReturn(false);
        });
        _and("not marked as deleted", function() {
          beforeEach(function() {
            return this.store._is_marked_as_deleted.andReturn(false);
          });
          return it("should clean it", function() {
            this.store.cache('couch', '123');
            return expect(this.store.clear_changed).wasCalledWith('couch', '123');
          });
        });
        return _but("marked as deleted", function() {
          beforeEach(function() {
            return this.store._is_marked_as_deleted.andReturn(true);
          });
          return it("should mark it as changed", function() {
            this.store.cache('couch', '123');
            return expect(this.store.mark_as_changed).wasCalledWith('couch', '123', {
              color: 'red',
              type: 'couch',
              id: '123'
            });
          });
        });
      });
      return it("should return the object including type & id attributes", function() {
        var obj;
        obj = this.store.cache('couch', '123', {
          color: 'red'
        });
        expect(obj.color).toBe('red');
        expect(obj.type).toBe('couch');
        return expect(obj.id).toBe('123');
      });
    });
    describe(".clear()", function() {
      it("should return a promise", function() {
        var promise;
        promise = this.store.clear();
        return expect(promise).toBePromise();
      });
      it("should clear localStorage", function() {
        this.store.clear();
        return expect(this.store.db.clear).wasCalled();
      });
      it("should clear chache", function() {
        this.store._cached = 'funky';
        this.store.clear();
        return expect($.isEmptyObject(this.store._cached)).toBeTruthy();
      });
      it("should clear dirty docs", function() {
        spyOn(this.store, "clear_changed");
        this.store.clear();
        return expect(this.store.clear_changed).wasCalled();
      });
      it("should resolve promise", function() {
        var promise;
        promise = this.store.clear();
        return expect(promise).toBeResolved();
      });
      return _when("an error occurs", function() {
        beforeEach(function() {
          return spyOn(this.store, "clear_changed").andCallFake(function() {
            throw new Error('ooops');
          });
        });
        return it("should reject the promise", function() {
          var promise;
          promise = this.store.clear();
          return expect(promise).toBeRejected();
        });
      });
    });
    describe(".is_dirty(type, id)", function() {
      _when("no arguments passed", function() {
        return it("returns true when there are no dirty documents", function() {
          this.store._dirty = {};
          return expect(this.store.is_dirty()).toBeTruthy();
        });
      });
      return _when("type & id passed", function() {
        _and("object was not yet synced", function() {
          beforeEach(function() {
            return spyOn(this.store, "cache").andReturn({
              _synced_at: void 0
            });
          });
          return it("should return true", function() {
            return expect(this.store.is_dirty('couch', '123')).toBeTruthy();
          });
        });
        return _and("object was synced", function() {
          _and("object was not updated yet", function() {
            beforeEach(function() {
              return spyOn(this.store, "cache").andReturn({
                _synced_at: new Date(0),
                updated_at: void 0
              });
            });
            return it("should return false", function() {
              return expect(this.store.is_dirty('couch', '123')).toBeFalsy();
            });
          });
          _and("object was updated at the same time", function() {
            beforeEach(function() {
              return spyOn(this.store, "cache").andReturn({
                _synced_at: new Date(0),
                updated_at: new Date(0)
              });
            });
            return it("should return false", function() {
              return expect(this.store.is_dirty('couch', '123')).toBeFalsy();
            });
          });
          return _and("object was updated later", function() {
            beforeEach(function() {
              return spyOn(this.store, "cache").andReturn({
                _synced_at: new Date(0),
                updated_at: new Date(1)
              });
            });
            return it("should return true", function() {
              return expect(this.store.is_dirty('couch', '123')).toBeTruthy();
            });
          });
        });
      });
    });
    describe(".mark_as_changed(type, id, object)", function() {
      beforeEach(function() {
        this.store._dirty = {};
        spyOn(window, "setTimeout").andReturn('new_timeout');
        spyOn(window, "clearTimeout");
        spyOn(this.hoodie, "trigger");
        return this.store.mark_as_changed('couch', '123', {
          color: 'red'
        });
      });
      it("should add it to the dirty list", function() {
        return expect(this.store._dirty['couch/123'].color).toBe('red');
      });
      it("should should trigger an `store:dirty` event", function() {
        return expect(this.hoodie.trigger).wasCalledWith('store:dirty');
      });
      it("should start dirty timeout for 2 seconds", function() {
        var args;
        args = window.setTimeout.mostRecentCall.args;
        expect(args[1]).toBe(2000);
        return expect(this.store._dirty_timeout).toBe('new_timeout');
      });
      return it("should clear dirty timeout", function() {
        this.store._dirty_timeout = 'timeout';
        this.store.mark_as_changed('couch', '123', {
          color: 'red'
        });
        return expect(window.clearTimeout).wasCalledWith('timeout');
      });
    });
    describe(".changed_docs()", function() {
      _when("there are no changed docs", function() {
        beforeEach(function() {
          return this.store._dirty = {};
        });
        return it("should return an empty array", function() {
          expect($.isArray(this.store.changed_docs())).toBeTruthy();
          return expect(this.store.changed_docs().length).toBe(0);
        });
      });
      return _when("there are 2 dirty docs", function() {
        beforeEach(function() {
          return this.store._dirty = [
            {
              type: 'couch',
              id: '123',
              color: 'red'
            }, {
              type: 'couch',
              id: '456',
              color: 'green'
            }
          ];
        });
        return it("should return the two docs", function() {
          return expect(this.store.changed_docs().length).toBe(2);
        });
      });
    });
    describe(".is_marked_as_deleted(type, id)", function() {
      _when("object 'couch/123' is marked as deleted", function() {
        beforeEach(function() {
          return spyOn(this.store, "cache").andReturn({
            _deleted: true
          });
        });
        return it("should return true", function() {
          return expect(this.store.is_marked_as_deleted('couch', '123')).toBeTruthy();
        });
      });
      return _when("object 'couch/123' isn't marked as deleted", function() {
        beforeEach(function() {
          return spyOn(this.store, "cache").andReturn({});
        });
        return it("should return false", function() {
          return expect(this.store.is_marked_as_deleted('couch', '123')).toBeFalsy();
        });
      });
    });
    describe(".clear_changed(type, id)", function() {
      _when("type & id passed", function() {
        return it("should remove the respective object from the dirty list", function() {
          this.store._dirty['couch/123'] = {
            color: 'red'
          };
          this.store.clear_changed('couch', 123);
          return expect(this.store._dirty['couch/123']).toBeUndefined();
        });
      });
      _when("no arguments passed", function() {
        return it("should remove all objects from the dirty list", function() {
          this.store._dirty = {
            'couch/123': {
              color: 'red'
            },
            'couch/456': {
              color: 'green'
            }
          };
          this.store.clear_changed();
          return expect($.isEmptyObject(this.store._dirty)).toBeTruthy();
        });
      });
      return it("should trigger a `store:dirty` event", function() {
        spyOn(this.hoodie, "trigger");
        this.store.clear_changed();
        return expect(this.hoodie.trigger).wasCalledWith('store:dirty');
      });
    });
    return describe(".uuid(num = 7)", function() {
      it("should default to a length of 7", function() {
        return expect(this.store.uuid().length).toBe(7);
      });
      return _when("called with num = 5", function() {
        return it("should generate an id with length = 5", function() {
          return expect(this.store.uuid(5).length).toBe(5);
        });
      });
    });
  });
});
